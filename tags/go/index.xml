<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Steve Leonard</title>
    <link>https://www.xsleonard.com/tags/go/</link>
    <description>Recent content in go on Steve Leonard</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Oct 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.xsleonard.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Common setup for a public HTTP server in Go</title>
      <link>https://www.xsleonard.com/common-setup-for-a-public-http-server-in-go/</link>
      <pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.xsleonard.com/common-setup-for-a-public-http-server-in-go/</guid>
      <description>These are common initial setups I use for public Go HTTP services.
 Configure the HTTP server with timeouts Process lifecycle: graceful shutdown CORS unrolled/secure: Security headers, SSL redirect, host whitelisting Gzip Let&amp;rsquo;s Encrypt Testing  Configure the HTTP server with timeouts The default HTTP server in the http package is not suitable for use as a public Go HTTP server because it does not have timeouts configured. Inevitably, this default server will see connection exhaustion running as a public service.</description>
    </item>
    
    <item>
      <title>Go coverage for external tests with Cobra</title>
      <link>https://www.xsleonard.com/go-coverage-for-external-tests-with-cobra/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.xsleonard.com/go-coverage-for-external-tests-with-cobra/</guid>
      <description>Prerequisite reading: Go coverage with external tests
Go coverage can be generated by a CLI tool by compiling it as a test binary and passing it the test coverage flags. There&amp;rsquo;s one catch: coverage will not be generated if the program does not exit with status 0, so its not possible to get coverage for tests of failure cases.
Instructions for generating coverage in this way are described in Go coverage with external tests and won&amp;rsquo;t be repeated here.</description>
    </item>
    
    <item>
      <title>Avoiding Locks in Golang</title>
      <link>https://www.xsleonard.com/avoiding-locks-in-golang/</link>
      <pubDate>Wed, 15 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://www.xsleonard.com/avoiding-locks-in-golang/</guid>
      <description>Golang maps are not safe for concurrent writes.
Common solutions are to use sync.Mutex, sync.RWMutex, or a mutex implemented with chan. Depending on how your application is structured, we can avoid locking with select.
Synchronizing map access with select package main import ( &amp;#34;math/rand&amp;#34; &amp;#34;time&amp;#34; ) var m = make(map[int]int) // Writes a random k,v pair to the map func write() { k := rand.Int() m[k] = rand.Int() } // Returns a random value stored in the map func read() int { keys := make([]int, 0, len(m)) for k, _ := range m { keys = append(keys, k) } key := keys[rand.</description>
    </item>
    
  </channel>
</rss>
